/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_magic-string_dist_magic-string_es_mjs"],{

/***/ "./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjL2Rpc3Qvc291cmNlbWFwLWNvZGVjLnVtZC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksQ0FDK0c7QUFDbkgsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQyxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRCxhQUFhOztBQUVoRSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYy9kaXN0L3NvdXJjZW1hcC1jb2RlYy51bWQuanM/YTg1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnNvdXJjZW1hcENvZGVjID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBjb21tYSA9ICcsJy5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IHNlbWljb2xvbiA9ICc7Jy5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIGNvbnN0IGludFRvQ2hhciA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gNjQgcG9zc2libGUgY2hhcnMuXG4gICAgY29uc3QgY2hhclRvSW50ID0gbmV3IFVpbnQ4QXJyYXkoMTI4KTsgLy8geiBpcyAxMjIgaW4gQVNDSUlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjaGFycy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpbnRUb0NoYXJbaV0gPSBjO1xuICAgICAgICBjaGFyVG9JbnRbY10gPSBpO1xuICAgIH1cbiAgICAvLyBQcm92aWRlIGEgZmFsbGJhY2sgZm9yIG9sZGVyIGVudmlyb25tZW50cy5cbiAgICBjb25zdCB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyAvKiAjX19QVVJFX18gKi8gbmV3IFRleHREZWNvZGVyKClcbiAgICAgICAgOiB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZGVjb2RlKGJ1Zikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBCdWZmZXIuZnJvbShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGRlY29kZShidWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgIGZ1bmN0aW9uIGRlY29kZShtYXBwaW5ncykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyBJbnQzMkFycmF5KDUpO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gW107XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbWkgPSBpbmRleE9mKG1hcHBpbmdzLCBpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gW107XG4gICAgICAgICAgICBsZXQgc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBsYXN0Q29sID0gMDtcbiAgICAgICAgICAgIHN0YXRlWzBdID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHNlbWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzZWc7XG4gICAgICAgICAgICAgICAgaSA9IGRlY29kZUludGVnZXIobWFwcGluZ3MsIGksIHN0YXRlLCAwKTsgLy8gZ2VuQ29sdW1uXG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gc3RhdGVbMF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbCA8IGxhc3RDb2wpXG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxhc3RDb2wgPSBjb2w7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01vcmVWbHEobWFwcGluZ3MsIGksIHNlbWkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBkZWNvZGVJbnRlZ2VyKG1hcHBpbmdzLCBpLCBzdGF0ZSwgMSk7IC8vIHNvdXJjZXNJbmRleFxuICAgICAgICAgICAgICAgICAgICBpID0gZGVjb2RlSW50ZWdlcihtYXBwaW5ncywgaSwgc3RhdGUsIDIpOyAvLyBzb3VyY2VMaW5lXG4gICAgICAgICAgICAgICAgICAgIGkgPSBkZWNvZGVJbnRlZ2VyKG1hcHBpbmdzLCBpLCBzdGF0ZSwgMyk7IC8vIHNvdXJjZUNvbHVtblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTW9yZVZscShtYXBwaW5ncywgaSwgc2VtaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBkZWNvZGVJbnRlZ2VyKG1hcHBpbmdzLCBpLCBzdGF0ZSwgNCk7IC8vIG5hbWVzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZyA9IFtjb2wsIHN0YXRlWzFdLCBzdGF0ZVsyXSwgc3RhdGVbM10sIHN0YXRlWzRdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZyA9IFtjb2wsIHN0YXRlWzFdLCBzdGF0ZVsyXSwgc3RhdGVbM11dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWcgPSBbY29sXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKHNlZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNvcnRlZClcbiAgICAgICAgICAgICAgICBzb3J0KGxpbmUpO1xuICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgaW5kZXggPSBzZW1pICsgMTtcbiAgICAgICAgfSB3aGlsZSAoaW5kZXggPD0gbWFwcGluZ3MubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGV4T2YobWFwcGluZ3MsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IG1hcHBpbmdzLmluZGV4T2YoJzsnLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBpZHggPT09IC0xID8gbWFwcGluZ3MubGVuZ3RoIDogaWR4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVJbnRlZ2VyKG1hcHBpbmdzLCBwb3MsIHN0YXRlLCBqKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGxldCBzaGlmdCA9IDA7XG4gICAgICAgIGxldCBpbnRlZ2VyID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYyA9IG1hcHBpbmdzLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICAgICAgaW50ZWdlciA9IGNoYXJUb0ludFtjXTtcbiAgICAgICAgICAgIHZhbHVlIHw9IChpbnRlZ2VyICYgMzEpIDw8IHNoaWZ0O1xuICAgICAgICAgICAgc2hpZnQgKz0gNTtcbiAgICAgICAgfSB3aGlsZSAoaW50ZWdlciAmIDMyKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkTmVnYXRlID0gdmFsdWUgJiAxO1xuICAgICAgICB2YWx1ZSA+Pj49IDE7XG4gICAgICAgIGlmIChzaG91bGROZWdhdGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gLTB4ODAwMDAwMDAgfCAtdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVbal0gKz0gdmFsdWU7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc01vcmVWbHEobWFwcGluZ3MsIGksIGxlbmd0aCkge1xuICAgICAgICBpZiAoaSA+PSBsZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBtYXBwaW5ncy5jaGFyQ29kZUF0KGkpICE9PSBjb21tYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc29ydChsaW5lKSB7XG4gICAgICAgIGxpbmUuc29ydChzb3J0Q29tcGFyYXRvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNvcnRDb21wYXJhdG9yKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUoZGVjb2RlZCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyBJbnQzMkFycmF5KDUpO1xuICAgICAgICBjb25zdCBidWZMZW5ndGggPSAxMDI0ICogMTY7XG4gICAgICAgIGNvbnN0IHN1Ykxlbmd0aCA9IGJ1Zkxlbmd0aCAtIDM2O1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShidWZMZW5ndGgpO1xuICAgICAgICBjb25zdCBzdWIgPSBidWYuc3ViYXJyYXkoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IGJ1Zkxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGQuZGVjb2RlKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBzZW1pY29sb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzdGF0ZVswXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gbGluZVtqXTtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcHVzaCB1cCB0byA1IGludHMsIGVhY2ggaW50IGNhbiB0YWtlIGF0IG1vc3QgNyBjaGFycywgYW5kIHdlXG4gICAgICAgICAgICAgICAgLy8gbWF5IHB1c2ggYSBjb21tYS5cbiAgICAgICAgICAgICAgICBpZiAocG9zID4gc3ViTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0ZC5kZWNvZGUoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmLmNvcHlXaXRoaW4oMCwgc3ViTGVuZ3RoLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgLT0gc3ViTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBjb21tYTtcbiAgICAgICAgICAgICAgICBwb3MgPSBlbmNvZGVJbnRlZ2VyKGJ1ZiwgcG9zLCBzdGF0ZSwgc2VnbWVudCwgMCk7IC8vIGdlbkNvbHVtblxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcG9zID0gZW5jb2RlSW50ZWdlcihidWYsIHBvcywgc3RhdGUsIHNlZ21lbnQsIDEpOyAvLyBzb3VyY2VzSW5kZXhcbiAgICAgICAgICAgICAgICBwb3MgPSBlbmNvZGVJbnRlZ2VyKGJ1ZiwgcG9zLCBzdGF0ZSwgc2VnbWVudCwgMik7IC8vIHNvdXJjZUxpbmVcbiAgICAgICAgICAgICAgICBwb3MgPSBlbmNvZGVJbnRlZ2VyKGJ1ZiwgcG9zLCBzdGF0ZSwgc2VnbWVudCwgMyk7IC8vIHNvdXJjZUNvbHVtblxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gNClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcG9zID0gZW5jb2RlSW50ZWdlcihidWYsIHBvcywgc3RhdGUsIHNlZ21lbnQsIDQpOyAvLyBuYW1lc0luZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dCArIHRkLmRlY29kZShidWYuc3ViYXJyYXkoMCwgcG9zKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUludGVnZXIoYnVmLCBwb3MsIHN0YXRlLCBzZWdtZW50LCBqKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBzZWdtZW50W2pdO1xuICAgICAgICBsZXQgbnVtID0gbmV4dCAtIHN0YXRlW2pdO1xuICAgICAgICBzdGF0ZVtqXSA9IG5leHQ7XG4gICAgICAgIG51bSA9IG51bSA8IDAgPyAoLW51bSA8PCAxKSB8IDEgOiBudW0gPDwgMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGV0IGNsYW1wZWQgPSBudW0gJiAwYjAxMTExMTtcbiAgICAgICAgICAgIG51bSA+Pj49IDU7XG4gICAgICAgICAgICBpZiAobnVtID4gMClcbiAgICAgICAgICAgICAgICBjbGFtcGVkIHw9IDBiMTAwMDAwO1xuICAgICAgICAgICAgYnVmW3BvcysrXSA9IGludFRvQ2hhcltjbGFtcGVkXTtcbiAgICAgICAgfSB3aGlsZSAobnVtID4gMCk7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4gICAgZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3VyY2VtYXAtY29kZWMudW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\n"));

/***/ }),

/***/ "./node_modules/magic-string/dist/magic-string.es.mjs":
/*!************************************************************!*\
  !*** ./node_modules/magic-string/dist/magic-string.es.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bundle: function() { return /* binding */ Bundle; },\n/* harmony export */   SourceMap: function() { return /* binding */ SourceMap; },\n/* harmony export */   \"default\": function() { return /* binding */ MagicString; }\n/* harmony export */ });\n/* harmony import */ var _jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + '' \n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.encode)(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nconst wordRegex = /\\w/;\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\t\treplacement\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\treplacement\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tif (previous !== replacement)\n\t\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\n\n//# sourceMappingURL=magic-string.es.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL2Rpc3QvbWFnaWMtc3RyaW5nLmVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQkFBZ0IsTUFBTTtBQUN6QixrQkFBa0IsTUFBTTtBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsR0FBRzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxZQUFZLDJCQUEyQjtBQUN2QyxZQUFZLDJCQUEyQjtBQUN2QyxpQkFBaUIsOEJBQThCO0FBQy9DLGdCQUFnQiw4QkFBOEI7QUFDOUMsd0JBQXdCLDhCQUE4QjtBQUN0RCxjQUFjLDJCQUEyQjtBQUN6QyxZQUFZLDJCQUEyQjtBQUN2QyxlQUFlLHlDQUF5QztBQUN4RCw0QkFBNEIsc0RBQXNEO0FBQ2xGLHlCQUF5QixxQ0FBcUM7QUFDOUQsa0JBQWtCLDJCQUEyQjtBQUM3QyxnQkFBZ0Isa0NBQWtDO0FBQ2xELGlCQUFpQiwyQ0FBMkM7QUFDNUQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QseUJBQXlCOztBQUUzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVSxFQUFFLE1BQU07QUFDOUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qyw2Q0FBNkM7QUFDekY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELE9BQU87O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxLQUFLOztBQUUxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTLEdBQUcsWUFBWSxLQUFLLGVBQWU7QUFDdEc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEIsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFdBQVc7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQTZEO0FBQzNGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRXFEO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYWdpYy1zdHJpbmcvZGlzdC9tYWdpYy1zdHJpbmcuZXMubWpzP2U5MDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSAnQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjJztcblxuY2xhc3MgQml0U2V0IHtcblx0Y29uc3RydWN0b3IoYXJnKSB7XG5cdFx0dGhpcy5iaXRzID0gYXJnIGluc3RhbmNlb2YgQml0U2V0ID8gYXJnLmJpdHMuc2xpY2UoKSA6IFtdO1xuXHR9XG5cblx0YWRkKG4pIHtcblx0XHR0aGlzLmJpdHNbbiA+PiA1XSB8PSAxIDw8IChuICYgMzEpO1xuXHR9XG5cblx0aGFzKG4pIHtcblx0XHRyZXR1cm4gISEodGhpcy5iaXRzW24gPj4gNV0gJiAoMSA8PCAobiAmIDMxKSkpO1xuXHR9XG59XG5cbmNsYXNzIENodW5rIHtcblx0Y29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgY29udGVudCkge1xuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLm9yaWdpbmFsID0gY29udGVudDtcblxuXHRcdHRoaXMuaW50cm8gPSAnJztcblx0XHR0aGlzLm91dHJvID0gJyc7XG5cblx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdHRoaXMuc3RvcmVOYW1lID0gZmFsc2U7XG5cdFx0dGhpcy5lZGl0ZWQgPSBmYWxzZTtcblxuXHRcdHtcblx0XHRcdHRoaXMucHJldmlvdXMgPSBudWxsO1xuXHRcdFx0dGhpcy5uZXh0ID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRhcHBlbmRMZWZ0KGNvbnRlbnQpIHtcblx0XHR0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG5cdH1cblxuXHRhcHBlbmRSaWdodChjb250ZW50KSB7XG5cdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8gKyBjb250ZW50O1xuXHR9XG5cblx0Y2xvbmUoKSB7XG5cdFx0Y29uc3QgY2h1bmsgPSBuZXcgQ2h1bmsodGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMub3JpZ2luYWwpO1xuXG5cdFx0Y2h1bmsuaW50cm8gPSB0aGlzLmludHJvO1xuXHRcdGNodW5rLm91dHJvID0gdGhpcy5vdXRybztcblx0XHRjaHVuay5jb250ZW50ID0gdGhpcy5jb250ZW50O1xuXHRcdGNodW5rLnN0b3JlTmFtZSA9IHRoaXMuc3RvcmVOYW1lO1xuXHRcdGNodW5rLmVkaXRlZCA9IHRoaXMuZWRpdGVkO1xuXG5cdFx0cmV0dXJuIGNodW5rO1xuXHR9XG5cblx0Y29udGFpbnMoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGFydCA8IGluZGV4ICYmIGluZGV4IDwgdGhpcy5lbmQ7XG5cdH1cblxuXHRlYWNoTmV4dChmbikge1xuXHRcdGxldCBjaHVuayA9IHRoaXM7XG5cdFx0d2hpbGUgKGNodW5rKSB7XG5cdFx0XHRmbihjaHVuayk7XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fVxuXHR9XG5cblx0ZWFjaFByZXZpb3VzKGZuKSB7XG5cdFx0bGV0IGNodW5rID0gdGhpcztcblx0XHR3aGlsZSAoY2h1bmspIHtcblx0XHRcdGZuKGNodW5rKTtcblx0XHRcdGNodW5rID0gY2h1bmsucHJldmlvdXM7XG5cdFx0fVxuXHR9XG5cblx0ZWRpdChjb250ZW50LCBzdG9yZU5hbWUsIGNvbnRlbnRPbmx5KSB7XG5cdFx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHRpZiAoIWNvbnRlbnRPbmx5KSB7XG5cdFx0XHR0aGlzLmludHJvID0gJyc7XG5cdFx0XHR0aGlzLm91dHJvID0gJyc7XG5cdFx0fVxuXHRcdHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lO1xuXG5cdFx0dGhpcy5lZGl0ZWQgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRwcmVwZW5kTGVmdChjb250ZW50KSB7XG5cdFx0dGhpcy5vdXRybyA9IGNvbnRlbnQgKyB0aGlzLm91dHJvO1xuXHR9XG5cblx0cHJlcGVuZFJpZ2h0KGNvbnRlbnQpIHtcblx0XHR0aGlzLmludHJvID0gY29udGVudCArIHRoaXMuaW50cm87XG5cdH1cblxuXHRyZXNldCgpIHtcblx0XHR0aGlzLmludHJvID0gJyc7XG5cdFx0dGhpcy5vdXRybyA9ICcnO1xuXHRcdGlmICh0aGlzLmVkaXRlZCkge1xuXHRcdFx0dGhpcy5jb250ZW50ID0gdGhpcy5vcmlnaW5hbDtcblx0XHRcdHRoaXMuc3RvcmVOYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLmVkaXRlZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHNwbGl0KGluZGV4KSB7XG5cdFx0Y29uc3Qgc2xpY2VJbmRleCA9IGluZGV4IC0gdGhpcy5zdGFydDtcblxuXHRcdGNvbnN0IG9yaWdpbmFsQmVmb3JlID0gdGhpcy5vcmlnaW5hbC5zbGljZSgwLCBzbGljZUluZGV4KTtcblx0XHRjb25zdCBvcmlnaW5hbEFmdGVyID0gdGhpcy5vcmlnaW5hbC5zbGljZShzbGljZUluZGV4KTtcblxuXHRcdHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbEJlZm9yZTtcblxuXHRcdGNvbnN0IG5ld0NodW5rID0gbmV3IENodW5rKGluZGV4LCB0aGlzLmVuZCwgb3JpZ2luYWxBZnRlcik7XG5cdFx0bmV3Q2h1bmsub3V0cm8gPSB0aGlzLm91dHJvO1xuXHRcdHRoaXMub3V0cm8gPSAnJztcblxuXHRcdHRoaXMuZW5kID0gaW5kZXg7XG5cblx0XHRpZiAodGhpcy5lZGl0ZWQpIHtcblx0XHRcdC8vIGFmdGVyIHNwbGl0IHdlIHNob3VsZCBzYXZlIHRoZSBlZGl0IGNvbnRlbnQgcmVjb3JkIGludG8gdGhlIGNvcnJlY3QgY2h1bmtcblx0XHRcdC8vIHRvIG1ha2Ugc3VyZSBzb3VyY2VtYXAgY29ycmVjdFxuXHRcdFx0Ly8gRm9yIGV4YW1wbGU6XG5cdFx0XHQvLyAnICB0ZXN0Jy50cmltKClcblx0XHRcdC8vICAgICBzcGxpdCAgIC0+ICcgICcgKyAndGVzdCdcblx0XHRcdC8vICAg4pyU77iPIGVkaXQgICAgLT4gJycgKyAndGVzdCdcblx0XHRcdC8vICAg4pyW77iPIGVkaXQgICAgLT4gJ3Rlc3QnICsgJycgXG5cdFx0XHQvLyBUT0RPIGlzIHRoaXMgYmxvY2sgbmVjZXNzYXJ5Py4uLlxuXHRcdFx0bmV3Q2h1bmsuZWRpdCgnJywgZmFsc2UpO1xuXHRcdFx0dGhpcy5jb250ZW50ID0gJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY29udGVudCA9IG9yaWdpbmFsQmVmb3JlO1xuXHRcdH1cblxuXHRcdG5ld0NodW5rLm5leHQgPSB0aGlzLm5leHQ7XG5cdFx0aWYgKG5ld0NodW5rLm5leHQpIG5ld0NodW5rLm5leHQucHJldmlvdXMgPSBuZXdDaHVuaztcblx0XHRuZXdDaHVuay5wcmV2aW91cyA9IHRoaXM7XG5cdFx0dGhpcy5uZXh0ID0gbmV3Q2h1bms7XG5cblx0XHRyZXR1cm4gbmV3Q2h1bms7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnRybyArIHRoaXMuY29udGVudCArIHRoaXMub3V0cm87XG5cdH1cblxuXHR0cmltRW5kKHJ4KSB7XG5cdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdGlmICh0aGlzLm91dHJvLmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cblx0XHRjb25zdCB0cmltbWVkID0gdGhpcy5jb250ZW50LnJlcGxhY2UocngsICcnKTtcblxuXHRcdGlmICh0cmltbWVkLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRyaW1tZWQgIT09IHRoaXMuY29udGVudCkge1xuXHRcdFx0XHR0aGlzLnNwbGl0KHRoaXMuc3RhcnQgKyB0cmltbWVkLmxlbmd0aCkuZWRpdCgnJywgdW5kZWZpbmVkLCB0cnVlKTtcblx0XHRcdFx0aWYgKHRoaXMuZWRpdGVkKSB7XG5cdFx0XHRcdFx0Ly8gc2F2ZSB0aGUgY2hhbmdlLCBpZiBpdCBoYXMgYmVlbiBlZGl0ZWRcblx0XHRcdFx0XHR0aGlzLmVkaXQodHJpbW1lZCwgdGhpcy5zdG9yZU5hbWUsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lZGl0KCcnLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdFx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cdFx0XHRpZiAodGhpcy5pbnRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdHRyaW1TdGFydChyeCkge1xuXHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRpZiAodGhpcy5pbnRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG5cdFx0Y29uc3QgdHJpbW1lZCA9IHRoaXMuY29udGVudC5yZXBsYWNlKHJ4LCAnJyk7XG5cblx0XHRpZiAodHJpbW1lZC5sZW5ndGgpIHtcblx0XHRcdGlmICh0cmltbWVkICE9PSB0aGlzLmNvbnRlbnQpIHtcblx0XHRcdFx0Y29uc3QgbmV3Q2h1bmsgPSB0aGlzLnNwbGl0KHRoaXMuZW5kIC0gdHJpbW1lZC5sZW5ndGgpO1xuXHRcdFx0XHRpZiAodGhpcy5lZGl0ZWQpIHtcblx0XHRcdFx0XHQvLyBzYXZlIHRoZSBjaGFuZ2UsIGlmIGl0IGhhcyBiZWVuIGVkaXRlZFxuXHRcdFx0XHRcdG5ld0NodW5rLmVkaXQodHJpbW1lZCwgdGhpcy5zdG9yZU5hbWUsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZWRpdCgnJywgdW5kZWZpbmVkLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVkaXQoJycsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0XHRcdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRcdGlmICh0aGlzLm91dHJvLmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGdldEJ0b2EoKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbFRoaXMuYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiAoc3RyKSA9PiBnbG9iYWxUaGlzLmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIChzdHIpID0+IEJ1ZmZlci5mcm9tKHN0ciwgJ3V0Zi04JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVudmlyb25tZW50OiBgd2luZG93LmJ0b2FgIG9yIGBCdWZmZXJgIHNob3VsZCBiZSBzdXBwb3J0ZWQuJyk7XG5cdFx0fTtcblx0fVxufVxuXG5jb25zdCBidG9hID0gLyojX19QVVJFX18qLyBnZXRCdG9hKCk7XG5cbmNsYXNzIFNvdXJjZU1hcCB7XG5cdGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnZlcnNpb24gPSAzO1xuXHRcdHRoaXMuZmlsZSA9IHByb3BlcnRpZXMuZmlsZTtcblx0XHR0aGlzLnNvdXJjZXMgPSBwcm9wZXJ0aWVzLnNvdXJjZXM7XG5cdFx0dGhpcy5zb3VyY2VzQ29udGVudCA9IHByb3BlcnRpZXMuc291cmNlc0NvbnRlbnQ7XG5cdFx0dGhpcy5uYW1lcyA9IHByb3BlcnRpZXMubmFtZXM7XG5cdFx0dGhpcy5tYXBwaW5ncyA9IGVuY29kZShwcm9wZXJ0aWVzLm1hcHBpbmdzKTtcblx0XHRpZiAodHlwZW9mIHByb3BlcnRpZXMueF9nb29nbGVfaWdub3JlTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMueF9nb29nbGVfaWdub3JlTGlzdCA9IHByb3BlcnRpZXMueF9nb29nbGVfaWdub3JlTGlzdDtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG5cdH1cblxuXHR0b1VybCgpIHtcblx0XHRyZXR1cm4gJ2RhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYnRvYSh0aGlzLnRvU3RyaW5nKCkpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGd1ZXNzSW5kZW50KGNvZGUpIHtcblx0Y29uc3QgbGluZXMgPSBjb2RlLnNwbGl0KCdcXG4nKTtcblxuXHRjb25zdCB0YWJiZWQgPSBsaW5lcy5maWx0ZXIoKGxpbmUpID0+IC9eXFx0Ky8udGVzdChsaW5lKSk7XG5cdGNvbnN0IHNwYWNlZCA9IGxpbmVzLmZpbHRlcigobGluZSkgPT4gL14gezIsfS8udGVzdChsaW5lKSk7XG5cblx0aWYgKHRhYmJlZC5sZW5ndGggPT09IDAgJiYgc3BhY2VkLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gTW9yZSBsaW5lcyB0YWJiZWQgdGhhbiBzcGFjZWQ/IEFzc3VtZSB0YWJzLCBhbmRcblx0Ly8gZGVmYXVsdCB0byB0YWJzIGluIHRoZSBjYXNlIG9mIGEgdGllIChvciBub3RoaW5nXG5cdC8vIHRvIGdvIG9uKVxuXHRpZiAodGFiYmVkLmxlbmd0aCA+PSBzcGFjZWQubGVuZ3RoKSB7XG5cdFx0cmV0dXJuICdcXHQnO1xuXHR9XG5cblx0Ly8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGd1ZXNzIHRoZSBtdWx0aXBsZVxuXHRjb25zdCBtaW4gPSBzcGFjZWQucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuXHRcdGNvbnN0IG51bVNwYWNlcyA9IC9eICsvLmV4ZWMoY3VycmVudClbMF0ubGVuZ3RoO1xuXHRcdHJldHVybiBNYXRoLm1pbihudW1TcGFjZXMsIHByZXZpb3VzKTtcblx0fSwgSW5maW5pdHkpO1xuXG5cdHJldHVybiBuZXcgQXJyYXkobWluICsgMSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBhdGgoZnJvbSwgdG8pIHtcblx0Y29uc3QgZnJvbVBhcnRzID0gZnJvbS5zcGxpdCgvWy9cXFxcXS8pO1xuXHRjb25zdCB0b1BhcnRzID0gdG8uc3BsaXQoL1svXFxcXF0vKTtcblxuXHRmcm9tUGFydHMucG9wKCk7IC8vIGdldCBkaXJuYW1lXG5cblx0d2hpbGUgKGZyb21QYXJ0c1swXSA9PT0gdG9QYXJ0c1swXSkge1xuXHRcdGZyb21QYXJ0cy5zaGlmdCgpO1xuXHRcdHRvUGFydHMuc2hpZnQoKTtcblx0fVxuXG5cdGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG5cdFx0bGV0IGkgPSBmcm9tUGFydHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIGZyb21QYXJ0c1tpXSA9ICcuLic7XG5cdH1cblxuXHRyZXR1cm4gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKS5qb2luKCcvJyk7XG59XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodGhpbmcpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gZ2V0TG9jYXRvcihzb3VyY2UpIHtcblx0Y29uc3Qgb3JpZ2luYWxMaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG5cdGNvbnN0IGxpbmVPZmZzZXRzID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBvcmlnaW5hbExpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGluZU9mZnNldHMucHVzaChwb3MpO1xuXHRcdHBvcyArPSBvcmlnaW5hbExpbmVzW2ldLmxlbmd0aCArIDE7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gbG9jYXRlKGluZGV4KSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGxldCBqID0gbGluZU9mZnNldHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpIDwgaikge1xuXHRcdFx0Y29uc3QgbSA9IChpICsgaikgPj4gMTtcblx0XHRcdGlmIChpbmRleCA8IGxpbmVPZmZzZXRzW21dKSB7XG5cdFx0XHRcdGogPSBtO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IG0gKyAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBsaW5lID0gaSAtIDE7XG5cdFx0Y29uc3QgY29sdW1uID0gaW5kZXggLSBsaW5lT2Zmc2V0c1tsaW5lXTtcblx0XHRyZXR1cm4geyBsaW5lLCBjb2x1bW4gfTtcblx0fTtcbn1cblxuY29uc3Qgd29yZFJlZ2V4ID0gL1xcdy87XG5cbmNsYXNzIE1hcHBpbmdzIHtcblx0Y29uc3RydWN0b3IoaGlyZXMpIHtcblx0XHR0aGlzLmhpcmVzID0gaGlyZXM7XG5cdFx0dGhpcy5nZW5lcmF0ZWRDb2RlTGluZSA9IDA7XG5cdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcblx0XHR0aGlzLnJhdyA9IFtdO1xuXHRcdHRoaXMucmF3U2VnbWVudHMgPSB0aGlzLnJhd1t0aGlzLmdlbmVyYXRlZENvZGVMaW5lXSA9IFtdO1xuXHRcdHRoaXMucGVuZGluZyA9IG51bGw7XG5cdH1cblxuXHRhZGRFZGl0KHNvdXJjZUluZGV4LCBjb250ZW50LCBsb2MsIG5hbWVJbmRleCkge1xuXHRcdGlmIChjb250ZW50Lmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgY29udGVudExlbmd0aE1pbnVzT25lID0gY29udGVudC5sZW5ndGggLSAxO1xuXHRcdFx0bGV0IGNvbnRlbnRMaW5lRW5kID0gY29udGVudC5pbmRleE9mKCdcXG4nLCAwKTtcblx0XHRcdGxldCBwcmV2aW91c0NvbnRlbnRMaW5lRW5kID0gLTE7XG5cdFx0XHQvLyBMb29wIHRocm91Z2ggZWFjaCBsaW5lIGluIHRoZSBjb250ZW50IGFuZCBhZGQgYSBzZWdtZW50LCBidXQgc3RvcCBpZiB0aGUgbGFzdCBsaW5lIGlzIGVtcHR5LFxuXHRcdFx0Ly8gZWxzZSBjb2RlIGFmdGVyd2FyZHMgd291bGQgZmlsbCBvbmUgbGluZSB0b28gbWFueVxuXHRcdFx0d2hpbGUgKGNvbnRlbnRMaW5lRW5kID49IDAgJiYgY29udGVudExlbmd0aE1pbnVzT25lID4gY29udGVudExpbmVFbmQpIHtcblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IFt0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4sIHNvdXJjZUluZGV4LCBsb2MubGluZSwgbG9jLmNvbHVtbl07XG5cdFx0XHRcdGlmIChuYW1lSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdHNlZ21lbnQucHVzaChuYW1lSW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmF3U2VnbWVudHMucHVzaChzZWdtZW50KTtcblxuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVMaW5lICs9IDE7XG5cdFx0XHRcdHRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdID0gdGhpcy5yYXdTZWdtZW50cyA9IFtdO1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXG5cdFx0XHRcdHByZXZpb3VzQ29udGVudExpbmVFbmQgPSBjb250ZW50TGluZUVuZDtcblx0XHRcdFx0Y29udGVudExpbmVFbmQgPSBjb250ZW50LmluZGV4T2YoJ1xcbicsIGNvbnRlbnRMaW5lRW5kICsgMSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlZ21lbnQgPSBbdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VJbmRleCwgbG9jLmxpbmUsIGxvYy5jb2x1bW5dO1xuXHRcdFx0aWYgKG5hbWVJbmRleCA+PSAwKSB7XG5cdFx0XHRcdHNlZ21lbnQucHVzaChuYW1lSW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yYXdTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXG5cdFx0XHR0aGlzLmFkdmFuY2UoY29udGVudC5zbGljZShwcmV2aW91c0NvbnRlbnRMaW5lRW5kICsgMSkpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nKSB7XG5cdFx0XHR0aGlzLnJhd1NlZ21lbnRzLnB1c2godGhpcy5wZW5kaW5nKTtcblx0XHRcdHRoaXMuYWR2YW5jZShjb250ZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLnBlbmRpbmcgPSBudWxsO1xuXHR9XG5cblx0YWRkVW5lZGl0ZWRDaHVuayhzb3VyY2VJbmRleCwgY2h1bmssIG9yaWdpbmFsLCBsb2MsIHNvdXJjZW1hcExvY2F0aW9ucykge1xuXHRcdGxldCBvcmlnaW5hbENoYXJJbmRleCA9IGNodW5rLnN0YXJ0O1xuXHRcdGxldCBmaXJzdCA9IHRydWU7XG5cdFx0Ly8gd2hlbiBpdGVyYXRpbmcgZWFjaCBjaGFyLCBjaGVjayBpZiBpdCdzIGluIGEgd29yZCBib3VuZGFyeVxuXHRcdGxldCBjaGFySW5IaXJlc0JvdW5kYXJ5ID0gZmFsc2U7XG5cblx0XHR3aGlsZSAob3JpZ2luYWxDaGFySW5kZXggPCBjaHVuay5lbmQpIHtcblx0XHRcdGlmICh0aGlzLmhpcmVzIHx8IGZpcnN0IHx8IHNvdXJjZW1hcExvY2F0aW9ucy5oYXMob3JpZ2luYWxDaGFySW5kZXgpKSB7XG5cdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSBbdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VJbmRleCwgbG9jLmxpbmUsIGxvYy5jb2x1bW5dO1xuXG5cdFx0XHRcdGlmICh0aGlzLmhpcmVzID09PSAnYm91bmRhcnknKSB7XG5cdFx0XHRcdFx0Ly8gaW4gaGlyZXMgXCJib3VuZGFyeVwiLCBncm91cCBzZWdtZW50cyBwZXIgd29yZCBib3VuZGFyeSB0aGFuIHBlciBjaGFyXG5cdFx0XHRcdFx0aWYgKHdvcmRSZWdleC50ZXN0KG9yaWdpbmFsW29yaWdpbmFsQ2hhckluZGV4XSkpIHtcblx0XHRcdFx0XHRcdC8vIGZvciBmaXJzdCBjaGFyIGluIHRoZSBib3VuZGFyeSBmb3VuZCwgc3RhcnQgdGhlIGJvdW5kYXJ5IGJ5IHB1c2hpbmcgYSBzZWdtZW50XG5cdFx0XHRcdFx0XHRpZiAoIWNoYXJJbkhpcmVzQm91bmRhcnkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5yYXdTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHRcdFx0XHRjaGFySW5IaXJlc0JvdW5kYXJ5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gZm9yIG5vbi13b3JkIGNoYXIsIGVuZCB0aGUgYm91bmRhcnkgYnkgcHVzaGluZyBhIHNlZ21lbnRcblx0XHRcdFx0XHRcdHRoaXMucmF3U2VnbWVudHMucHVzaChzZWdtZW50KTtcblx0XHRcdFx0XHRcdGNoYXJJbkhpcmVzQm91bmRhcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yYXdTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcmlnaW5hbFtvcmlnaW5hbENoYXJJbmRleF0gPT09ICdcXG4nKSB7XG5cdFx0XHRcdGxvYy5saW5lICs9IDE7XG5cdFx0XHRcdGxvYy5jb2x1bW4gPSAwO1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVMaW5lICs9IDE7XG5cdFx0XHRcdHRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdID0gdGhpcy5yYXdTZWdtZW50cyA9IFtdO1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXHRcdFx0XHRmaXJzdCA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2MuY29sdW1uICs9IDE7XG5cdFx0XHRcdHRoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbiArPSAxO1xuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRvcmlnaW5hbENoYXJJbmRleCArPSAxO1xuXHRcdH1cblxuXHRcdHRoaXMucGVuZGluZyA9IG51bGw7XG5cdH1cblxuXHRhZHZhbmNlKHN0cikge1xuXHRcdGlmICghc3RyKSByZXR1cm47XG5cblx0XHRjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgnXFxuJyk7XG5cblx0XHRpZiAobGluZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRcdFx0dGhpcy5nZW5lcmF0ZWRDb2RlTGluZSsrO1xuXHRcdFx0XHR0aGlzLnJhd1t0aGlzLmdlbmVyYXRlZENvZGVMaW5lXSA9IHRoaXMucmF3U2VnbWVudHMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uICs9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcblx0fVxufVxuXG5jb25zdCBuID0gJ1xcbic7XG5cbmNvbnN0IHdhcm5lZCA9IHtcblx0aW5zZXJ0TGVmdDogZmFsc2UsXG5cdGluc2VydFJpZ2h0OiBmYWxzZSxcblx0c3RvcmVOYW1lOiBmYWxzZSxcbn07XG5cbmNsYXNzIE1hZ2ljU3RyaW5nIHtcblx0Y29uc3RydWN0b3Ioc3RyaW5nLCBvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCBjaHVuayA9IG5ldyBDaHVuaygwLCBzdHJpbmcubGVuZ3RoLCBzdHJpbmcpO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdFx0b3JpZ2luYWw6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBzdHJpbmcgfSxcblx0XHRcdG91dHJvOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogJycgfSxcblx0XHRcdGludHJvOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogJycgfSxcblx0XHRcdGZpcnN0Q2h1bms6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBjaHVuayB9LFxuXHRcdFx0bGFzdENodW5rOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogY2h1bmsgfSxcblx0XHRcdGxhc3RTZWFyY2hlZENodW5rOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogY2h1bmsgfSxcblx0XHRcdGJ5U3RhcnQ6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuXHRcdFx0YnlFbmQ6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuXHRcdFx0ZmlsZW5hbWU6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBvcHRpb25zLmZpbGVuYW1lIH0sXG5cdFx0XHRpbmRlbnRFeGNsdXNpb25SYW5nZXM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBvcHRpb25zLmluZGVudEV4Y2x1c2lvblJhbmdlcyB9LFxuXHRcdFx0c291cmNlbWFwTG9jYXRpb25zOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbmV3IEJpdFNldCgpIH0sXG5cdFx0XHRzdG9yZWROYW1lczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG5cdFx0XHRpbmRlbnRTdHI6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSxcblx0XHRcdGlnbm9yZUxpc3Q6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBvcHRpb25zLmlnbm9yZUxpc3QgfSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYnlTdGFydFswXSA9IGNodW5rO1xuXHRcdHRoaXMuYnlFbmRbc3RyaW5nLmxlbmd0aF0gPSBjaHVuaztcblx0fVxuXG5cdGFkZFNvdXJjZW1hcExvY2F0aW9uKGNoYXIpIHtcblx0XHR0aGlzLnNvdXJjZW1hcExvY2F0aW9ucy5hZGQoY2hhcik7XG5cdH1cblxuXHRhcHBlbmQoY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ291dHJvIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0dGhpcy5vdXRybyArPSBjb250ZW50O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YXBwZW5kTGVmdChpbmRleCwgY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0dGhpcy5fc3BsaXQoaW5kZXgpO1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLmJ5RW5kW2luZGV4XTtcblxuXHRcdGlmIChjaHVuaykge1xuXHRcdFx0Y2h1bmsuYXBwZW5kTGVmdChjb250ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbnRybyArPSBjb250ZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGFwcGVuZFJpZ2h0KGluZGV4LCBjb250ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zZXJ0ZWQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cblx0XHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0XHRjb25zdCBjaHVuayA9IHRoaXMuYnlTdGFydFtpbmRleF07XG5cblx0XHRpZiAoY2h1bmspIHtcblx0XHRcdGNodW5rLmFwcGVuZFJpZ2h0KGNvbnRlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Y2xvbmUoKSB7XG5cdFx0Y29uc3QgY2xvbmVkID0gbmV3IE1hZ2ljU3RyaW5nKHRoaXMub3JpZ2luYWwsIHsgZmlsZW5hbWU6IHRoaXMuZmlsZW5hbWUgfSk7XG5cblx0XHRsZXQgb3JpZ2luYWxDaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHRsZXQgY2xvbmVkQ2h1bmsgPSAoY2xvbmVkLmZpcnN0Q2h1bmsgPSBjbG9uZWQubGFzdFNlYXJjaGVkQ2h1bmsgPSBvcmlnaW5hbENodW5rLmNsb25lKCkpO1xuXG5cdFx0d2hpbGUgKG9yaWdpbmFsQ2h1bmspIHtcblx0XHRcdGNsb25lZC5ieVN0YXJ0W2Nsb25lZENodW5rLnN0YXJ0XSA9IGNsb25lZENodW5rO1xuXHRcdFx0Y2xvbmVkLmJ5RW5kW2Nsb25lZENodW5rLmVuZF0gPSBjbG9uZWRDaHVuaztcblxuXHRcdFx0Y29uc3QgbmV4dE9yaWdpbmFsQ2h1bmsgPSBvcmlnaW5hbENodW5rLm5leHQ7XG5cdFx0XHRjb25zdCBuZXh0Q2xvbmVkQ2h1bmsgPSBuZXh0T3JpZ2luYWxDaHVuayAmJiBuZXh0T3JpZ2luYWxDaHVuay5jbG9uZSgpO1xuXG5cdFx0XHRpZiAobmV4dENsb25lZENodW5rKSB7XG5cdFx0XHRcdGNsb25lZENodW5rLm5leHQgPSBuZXh0Q2xvbmVkQ2h1bms7XG5cdFx0XHRcdG5leHRDbG9uZWRDaHVuay5wcmV2aW91cyA9IGNsb25lZENodW5rO1xuXG5cdFx0XHRcdGNsb25lZENodW5rID0gbmV4dENsb25lZENodW5rO1xuXHRcdFx0fVxuXG5cdFx0XHRvcmlnaW5hbENodW5rID0gbmV4dE9yaWdpbmFsQ2h1bms7XG5cdFx0fVxuXG5cdFx0Y2xvbmVkLmxhc3RDaHVuayA9IGNsb25lZENodW5rO1xuXG5cdFx0aWYgKHRoaXMuaW5kZW50RXhjbHVzaW9uUmFuZ2VzKSB7XG5cdFx0XHRjbG9uZWQuaW5kZW50RXhjbHVzaW9uUmFuZ2VzID0gdGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXMuc2xpY2UoKTtcblx0XHR9XG5cblx0XHRjbG9uZWQuc291cmNlbWFwTG9jYXRpb25zID0gbmV3IEJpdFNldCh0aGlzLnNvdXJjZW1hcExvY2F0aW9ucyk7XG5cblx0XHRjbG9uZWQuaW50cm8gPSB0aGlzLmludHJvO1xuXHRcdGNsb25lZC5vdXRybyA9IHRoaXMub3V0cm87XG5cblx0XHRyZXR1cm4gY2xvbmVkO1xuXHR9XG5cblx0Z2VuZXJhdGVEZWNvZGVkTWFwKG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdGNvbnN0IHNvdXJjZUluZGV4ID0gMDtcblx0XHRjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuc3RvcmVkTmFtZXMpO1xuXHRcdGNvbnN0IG1hcHBpbmdzID0gbmV3IE1hcHBpbmdzKG9wdGlvbnMuaGlyZXMpO1xuXG5cdFx0Y29uc3QgbG9jYXRlID0gZ2V0TG9jYXRvcih0aGlzLm9yaWdpbmFsKTtcblxuXHRcdGlmICh0aGlzLmludHJvKSB7XG5cdFx0XHRtYXBwaW5ncy5hZHZhbmNlKHRoaXMuaW50cm8pO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyc3RDaHVuay5lYWNoTmV4dCgoY2h1bmspID0+IHtcblx0XHRcdGNvbnN0IGxvYyA9IGxvY2F0ZShjaHVuay5zdGFydCk7XG5cblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGgpIG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsuaW50cm8pO1xuXG5cdFx0XHRpZiAoY2h1bmsuZWRpdGVkKSB7XG5cdFx0XHRcdG1hcHBpbmdzLmFkZEVkaXQoXG5cdFx0XHRcdFx0c291cmNlSW5kZXgsXG5cdFx0XHRcdFx0Y2h1bmsuY29udGVudCxcblx0XHRcdFx0XHRsb2MsXG5cdFx0XHRcdFx0Y2h1bmsuc3RvcmVOYW1lID8gbmFtZXMuaW5kZXhPZihjaHVuay5vcmlnaW5hbCkgOiAtMSxcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hcHBpbmdzLmFkZFVuZWRpdGVkQ2h1bmsoc291cmNlSW5kZXgsIGNodW5rLCB0aGlzLm9yaWdpbmFsLCBsb2MsIHRoaXMuc291cmNlbWFwTG9jYXRpb25zKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNodW5rLm91dHJvLmxlbmd0aCkgbWFwcGluZ3MuYWR2YW5jZShjaHVuay5vdXRybyk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZmlsZTogb3B0aW9ucy5maWxlID8gb3B0aW9ucy5maWxlLnNwbGl0KC9bL1xcXFxdLykucG9wKCkgOiB1bmRlZmluZWQsXG5cdFx0XHRzb3VyY2VzOiBbXG5cdFx0XHRcdG9wdGlvbnMuc291cmNlID8gZ2V0UmVsYXRpdmVQYXRoKG9wdGlvbnMuZmlsZSB8fCAnJywgb3B0aW9ucy5zb3VyY2UpIDogb3B0aW9ucy5maWxlIHx8ICcnLFxuXHRcdFx0XSxcblx0XHRcdHNvdXJjZXNDb250ZW50OiBvcHRpb25zLmluY2x1ZGVDb250ZW50ID8gW3RoaXMub3JpZ2luYWxdIDogdW5kZWZpbmVkLFxuXHRcdFx0bmFtZXMsXG5cdFx0XHRtYXBwaW5nczogbWFwcGluZ3MucmF3LFxuXHRcdFx0eF9nb29nbGVfaWdub3JlTGlzdDogdGhpcy5pZ25vcmVMaXN0ID8gW3NvdXJjZUluZGV4XSA6IHVuZGVmaW5lZCxcblx0XHR9O1xuXHR9XG5cblx0Z2VuZXJhdGVNYXAob3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgU291cmNlTWFwKHRoaXMuZ2VuZXJhdGVEZWNvZGVkTWFwKG9wdGlvbnMpKTtcblx0fVxuXG5cdF9lbnN1cmVpbmRlbnRTdHIoKSB7XG5cdFx0aWYgKHRoaXMuaW5kZW50U3RyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuaW5kZW50U3RyID0gZ3Vlc3NJbmRlbnQodGhpcy5vcmlnaW5hbCk7XG5cdFx0fVxuXHR9XG5cblx0X2dldFJhd0luZGVudFN0cmluZygpIHtcblx0XHR0aGlzLl9lbnN1cmVpbmRlbnRTdHIoKTtcblx0XHRyZXR1cm4gdGhpcy5pbmRlbnRTdHI7XG5cdH1cblxuXHRnZXRJbmRlbnRTdHJpbmcoKSB7XG5cdFx0dGhpcy5fZW5zdXJlaW5kZW50U3RyKCk7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZW50U3RyID09PSBudWxsID8gJ1xcdCcgOiB0aGlzLmluZGVudFN0cjtcblx0fVxuXG5cdGluZGVudChpbmRlbnRTdHIsIG9wdGlvbnMpIHtcblx0XHRjb25zdCBwYXR0ZXJuID0gL15bXlxcclxcbl0vZ207XG5cblx0XHRpZiAoaXNPYmplY3QoaW5kZW50U3RyKSkge1xuXHRcdFx0b3B0aW9ucyA9IGluZGVudFN0cjtcblx0XHRcdGluZGVudFN0ciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAoaW5kZW50U3RyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2Vuc3VyZWluZGVudFN0cigpO1xuXHRcdFx0aW5kZW50U3RyID0gdGhpcy5pbmRlbnRTdHIgfHwgJ1xcdCc7XG5cdFx0fVxuXG5cdFx0aWYgKGluZGVudFN0ciA9PT0gJycpIHJldHVybiB0aGlzOyAvLyBub29wXG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIFByb2Nlc3MgZXhjbHVzaW9uIHJhbmdlc1xuXHRcdGNvbnN0IGlzRXhjbHVkZWQgPSB7fTtcblxuXHRcdGlmIChvcHRpb25zLmV4Y2x1ZGUpIHtcblx0XHRcdGNvbnN0IGV4Y2x1c2lvbnMgPVxuXHRcdFx0XHR0eXBlb2Ygb3B0aW9ucy5leGNsdWRlWzBdID09PSAnbnVtYmVyJyA/IFtvcHRpb25zLmV4Y2x1ZGVdIDogb3B0aW9ucy5leGNsdWRlO1xuXHRcdFx0ZXhjbHVzaW9ucy5mb3JFYWNoKChleGNsdXNpb24pID0+IHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IGV4Y2x1c2lvblswXTsgaSA8IGV4Y2x1c2lvblsxXTsgaSArPSAxKSB7XG5cdFx0XHRcdFx0aXNFeGNsdWRlZFtpXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGxldCBzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyID0gb3B0aW9ucy5pbmRlbnRTdGFydCAhPT0gZmFsc2U7XG5cdFx0Y29uc3QgcmVwbGFjZXIgPSAobWF0Y2gpID0+IHtcblx0XHRcdGlmIChzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyKSByZXR1cm4gYCR7aW5kZW50U3RyfSR7bWF0Y2h9YDtcblx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH07XG5cblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VyKTtcblxuXHRcdGxldCBjaGFySW5kZXggPSAwO1xuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblxuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0Y29uc3QgZW5kID0gY2h1bmsuZW5kO1xuXG5cdFx0XHRpZiAoY2h1bmsuZWRpdGVkKSB7XG5cdFx0XHRcdGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG5cdFx0XHRcdFx0Y2h1bmsuY29udGVudCA9IGNodW5rLmNvbnRlbnQucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlcik7XG5cblx0XHRcdFx0XHRpZiAoY2h1bmsuY29udGVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSBjaHVuay5jb250ZW50W2NodW5rLmNvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhckluZGV4ID0gY2h1bmsuc3RhcnQ7XG5cblx0XHRcdFx0d2hpbGUgKGNoYXJJbmRleCA8IGVuZCkge1xuXHRcdFx0XHRcdGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjaGFyID0gdGhpcy5vcmlnaW5hbFtjaGFySW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRpZiAoY2hhciA9PT0gJ1xcbicpIHtcblx0XHRcdFx0XHRcdFx0c2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNoYXIgIT09ICdcXHInICYmIHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIpIHtcblx0XHRcdFx0XHRcdFx0c2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChjaGFySW5kZXggPT09IGNodW5rLnN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KGluZGVudFN0cik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc3BsaXRDaHVuayhjaHVuaywgY2hhckluZGV4KTtcblx0XHRcdFx0XHRcdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KGluZGVudFN0cik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjaGFySW5kZXggKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFySW5kZXggPSBjaHVuay5lbmQ7XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGluc2VydCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHQnbWFnaWNTdHJpbmcuaW5zZXJ0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIHByZXBlbmRSaWdodCguLi4pIG9yIGFwcGVuZExlZnQoLi4uKScsXG5cdFx0KTtcblx0fVxuXG5cdGluc2VydExlZnQoaW5kZXgsIGNvbnRlbnQpIHtcblx0XHRpZiAoIXdhcm5lZC5pbnNlcnRMZWZ0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdtYWdpY1N0cmluZy5pbnNlcnRMZWZ0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIG1hZ2ljU3RyaW5nLmFwcGVuZExlZnQoLi4uKSBpbnN0ZWFkJyxcblx0XHRcdCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHRcdFx0d2FybmVkLmluc2VydExlZnQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFwcGVuZExlZnQoaW5kZXgsIGNvbnRlbnQpO1xuXHR9XG5cblx0aW5zZXJ0UmlnaHQoaW5kZXgsIGNvbnRlbnQpIHtcblx0XHRpZiAoIXdhcm5lZC5pbnNlcnRSaWdodCkge1xuXHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHQnbWFnaWNTdHJpbmcuaW5zZXJ0UmlnaHQoLi4uKSBpcyBkZXByZWNhdGVkLiBVc2UgbWFnaWNTdHJpbmcucHJlcGVuZFJpZ2h0KC4uLikgaW5zdGVhZCcsXG5cdFx0XHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0XHRcdHdhcm5lZC5pbnNlcnRSaWdodCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHJlcGVuZFJpZ2h0KGluZGV4LCBjb250ZW50KTtcblx0fVxuXG5cdG1vdmUoc3RhcnQsIGVuZCwgaW5kZXgpIHtcblx0XHRpZiAoaW5kZXggPj0gc3RhcnQgJiYgaW5kZXggPD0gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtb3ZlIGEgc2VsZWN0aW9uIGluc2lkZSBpdHNlbGYnKTtcblxuXHRcdHRoaXMuX3NwbGl0KHN0YXJ0KTtcblx0XHR0aGlzLl9zcGxpdChlbmQpO1xuXHRcdHRoaXMuX3NwbGl0KGluZGV4KTtcblxuXHRcdGNvbnN0IGZpcnN0ID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcblx0XHRjb25zdCBsYXN0ID0gdGhpcy5ieUVuZFtlbmRdO1xuXG5cdFx0Y29uc3Qgb2xkTGVmdCA9IGZpcnN0LnByZXZpb3VzO1xuXHRcdGNvbnN0IG9sZFJpZ2h0ID0gbGFzdC5uZXh0O1xuXG5cdFx0Y29uc3QgbmV3UmlnaHQgPSB0aGlzLmJ5U3RhcnRbaW5kZXhdO1xuXHRcdGlmICghbmV3UmlnaHQgJiYgbGFzdCA9PT0gdGhpcy5sYXN0Q2h1bmspIHJldHVybiB0aGlzO1xuXHRcdGNvbnN0IG5ld0xlZnQgPSBuZXdSaWdodCA/IG5ld1JpZ2h0LnByZXZpb3VzIDogdGhpcy5sYXN0Q2h1bms7XG5cblx0XHRpZiAob2xkTGVmdCkgb2xkTGVmdC5uZXh0ID0gb2xkUmlnaHQ7XG5cdFx0aWYgKG9sZFJpZ2h0KSBvbGRSaWdodC5wcmV2aW91cyA9IG9sZExlZnQ7XG5cblx0XHRpZiAobmV3TGVmdCkgbmV3TGVmdC5uZXh0ID0gZmlyc3Q7XG5cdFx0aWYgKG5ld1JpZ2h0KSBuZXdSaWdodC5wcmV2aW91cyA9IGxhc3Q7XG5cblx0XHRpZiAoIWZpcnN0LnByZXZpb3VzKSB0aGlzLmZpcnN0Q2h1bmsgPSBsYXN0Lm5leHQ7XG5cdFx0aWYgKCFsYXN0Lm5leHQpIHtcblx0XHRcdHRoaXMubGFzdENodW5rID0gZmlyc3QucHJldmlvdXM7XG5cdFx0XHR0aGlzLmxhc3RDaHVuay5uZXh0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRmaXJzdC5wcmV2aW91cyA9IG5ld0xlZnQ7XG5cdFx0bGFzdC5uZXh0ID0gbmV3UmlnaHQgfHwgbnVsbDtcblxuXHRcdGlmICghbmV3TGVmdCkgdGhpcy5maXJzdENodW5rID0gZmlyc3Q7XG5cdFx0aWYgKCFuZXdSaWdodCkgdGhpcy5sYXN0Q2h1bmsgPSBsYXN0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0b3ZlcndyaXRlKHN0YXJ0LCBlbmQsIGNvbnRlbnQsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoc3RhcnQsIGVuZCwgY29udGVudCwgeyAuLi5vcHRpb25zLCBvdmVyd3JpdGU6ICFvcHRpb25zLmNvbnRlbnRPbmx5IH0pO1xuXHR9XG5cblx0dXBkYXRlKHN0YXJ0LCBlbmQsIGNvbnRlbnQsIG9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXBsYWNlbWVudCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuXHRcdHdoaWxlIChzdGFydCA8IDApIHN0YXJ0ICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXHRcdHdoaWxlIChlbmQgPCAwKSBlbmQgKz0gdGhpcy5vcmlnaW5hbC5sZW5ndGg7XG5cblx0XHRpZiAoZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZW5kIGlzIG91dCBvZiBib3VuZHMnKTtcblx0XHRpZiAoc3RhcnQgPT09IGVuZClcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J0Nhbm5vdCBvdmVyd3JpdGUgYSB6ZXJvLWxlbmd0aCByYW5nZSDigJMgdXNlIGFwcGVuZExlZnQgb3IgcHJlcGVuZFJpZ2h0IGluc3RlYWQnLFxuXHRcdFx0KTtcblxuXHRcdHRoaXMuX3NwbGl0KHN0YXJ0KTtcblx0XHR0aGlzLl9zcGxpdChlbmQpO1xuXG5cdFx0aWYgKG9wdGlvbnMgPT09IHRydWUpIHtcblx0XHRcdGlmICghd2FybmVkLnN0b3JlTmFtZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0J1RoZSBmaW5hbCBhcmd1bWVudCB0byBtYWdpY1N0cmluZy5vdmVyd3JpdGUoLi4uKSBzaG91bGQgYmUgYW4gb3B0aW9ucyBvYmplY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmljaC1oYXJyaXMvbWFnaWMtc3RyaW5nJyxcblx0XHRcdFx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdHdhcm5lZC5zdG9yZU5hbWUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zID0geyBzdG9yZU5hbWU6IHRydWUgfTtcblx0XHR9XG5cdFx0Y29uc3Qgc3RvcmVOYW1lID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdG9yZU5hbWUgOiBmYWxzZTtcblx0XHRjb25zdCBvdmVyd3JpdGUgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm92ZXJ3cml0ZSA6IGZhbHNlO1xuXG5cdFx0aWYgKHN0b3JlTmFtZSkge1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWwgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuc3RvcmVkTmFtZXMsIG9yaWdpbmFsLCB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpcnN0ID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcblx0XHRjb25zdCBsYXN0ID0gdGhpcy5ieUVuZFtlbmRdO1xuXG5cdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRsZXQgY2h1bmsgPSBmaXJzdDtcblx0XHRcdHdoaWxlIChjaHVuayAhPT0gbGFzdCkge1xuXHRcdFx0XHRpZiAoY2h1bmsubmV4dCAhPT0gdGhpcy5ieVN0YXJ0W2NodW5rLmVuZF0pIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvdmVyd3JpdGUgYWNyb3NzIGEgc3BsaXQgcG9pbnQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdGNodW5rLmVkaXQoJycsIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0Zmlyc3QuZWRpdChjb250ZW50LCBzdG9yZU5hbWUsICFvdmVyd3JpdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBtdXN0IGJlIGluc2VydGluZyBhdCB0aGUgZW5kXG5cdFx0XHRjb25zdCBuZXdDaHVuayA9IG5ldyBDaHVuayhzdGFydCwgZW5kLCAnJykuZWRpdChjb250ZW50LCBzdG9yZU5hbWUpO1xuXG5cdFx0XHQvLyBUT0RPIGxhc3QgY2h1bmsgaW4gdGhlIGFycmF5IG1heSBub3QgYmUgdGhlIGxhc3QgY2h1bmssIGlmIGl0J3MgbW92ZWQuLi5cblx0XHRcdGxhc3QubmV4dCA9IG5ld0NodW5rO1xuXHRcdFx0bmV3Q2h1bmsucHJldmlvdXMgPSBsYXN0O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHByZXBlbmQoY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ291dHJvIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0dGhpcy5pbnRybyA9IGNvbnRlbnQgKyB0aGlzLmludHJvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cHJlcGVuZExlZnQoaW5kZXgsIGNvbnRlbnQpIHtcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuXHRcdHRoaXMuX3NwbGl0KGluZGV4KTtcblxuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5ieUVuZFtpbmRleF07XG5cblx0XHRpZiAoY2h1bmspIHtcblx0XHRcdGNodW5rLnByZXBlbmRMZWZ0KGNvbnRlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmludHJvID0gY29udGVudCArIHRoaXMuaW50cm87XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cHJlcGVuZFJpZ2h0KGluZGV4LCBjb250ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zZXJ0ZWQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cblx0XHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0XHRjb25zdCBjaHVuayA9IHRoaXMuYnlTdGFydFtpbmRleF07XG5cblx0XHRpZiAoY2h1bmspIHtcblx0XHRcdGNodW5rLnByZXBlbmRSaWdodChjb250ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vdXRybyA9IGNvbnRlbnQgKyB0aGlzLm91dHJvO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJlbW92ZShzdGFydCwgZW5kKSB7XG5cdFx0d2hpbGUgKHN0YXJ0IDwgMCkgc3RhcnQgKz0gdGhpcy5vcmlnaW5hbC5sZW5ndGg7XG5cdFx0d2hpbGUgKGVuZCA8IDApIGVuZCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblxuXHRcdGlmIChzdGFydCA9PT0gZW5kKSByZXR1cm4gdGhpcztcblxuXHRcdGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2hhcmFjdGVyIGlzIG91dCBvZiBib3VuZHMnKTtcblx0XHRpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignZW5kIG11c3QgYmUgZ3JlYXRlciB0aGFuIHN0YXJ0Jyk7XG5cblx0XHR0aGlzLl9zcGxpdChzdGFydCk7XG5cdFx0dGhpcy5fc3BsaXQoZW5kKTtcblxuXHRcdGxldCBjaHVuayA9IHRoaXMuYnlTdGFydFtzdGFydF07XG5cblx0XHR3aGlsZSAoY2h1bmspIHtcblx0XHRcdGNodW5rLmludHJvID0gJyc7XG5cdFx0XHRjaHVuay5vdXRybyA9ICcnO1xuXHRcdFx0Y2h1bmsuZWRpdCgnJyk7XG5cblx0XHRcdGNodW5rID0gZW5kID4gY2h1bmsuZW5kID8gdGhpcy5ieVN0YXJ0W2NodW5rLmVuZF0gOiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJlc2V0KHN0YXJ0LCBlbmQpIHtcblx0XHR3aGlsZSAoc3RhcnQgPCAwKSBzdGFydCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHR3aGlsZSAoZW5kIDwgMCkgZW5kICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXG5cdFx0aWYgKHN0YXJ0ID09PSBlbmQpIHJldHVybiB0aGlzO1xuXG5cdFx0aWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLm9yaWdpbmFsLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDaGFyYWN0ZXIgaXMgb3V0IG9mIGJvdW5kcycpO1xuXHRcdGlmIChzdGFydCA+IGVuZCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnQnKTtcblxuXHRcdHRoaXMuX3NwbGl0KHN0YXJ0KTtcblx0XHR0aGlzLl9zcGxpdChlbmQpO1xuXG5cdFx0bGV0IGNodW5rID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcblxuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0Y2h1bmsucmVzZXQoKTtcblxuXHRcdFx0Y2h1bmsgPSBlbmQgPiBjaHVuay5lbmQgPyB0aGlzLmJ5U3RhcnRbY2h1bmsuZW5kXSA6IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bGFzdENoYXIoKSB7XG5cdFx0aWYgKHRoaXMub3V0cm8ubGVuZ3RoKSByZXR1cm4gdGhpcy5vdXRyb1t0aGlzLm91dHJvLmxlbmd0aCAtIDFdO1xuXHRcdGxldCBjaHVuayA9IHRoaXMubGFzdENodW5rO1xuXHRcdGRvIHtcblx0XHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGgpIHJldHVybiBjaHVuay5vdXRyb1tjaHVuay5vdXRyby5sZW5ndGggLSAxXTtcblx0XHRcdGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCkgcmV0dXJuIGNodW5rLmNvbnRlbnRbY2h1bmsuY29udGVudC5sZW5ndGggLSAxXTtcblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGgpIHJldHVybiBjaHVuay5pbnRyb1tjaHVuay5pbnRyby5sZW5ndGggLSAxXTtcblx0XHR9IHdoaWxlICgoY2h1bmsgPSBjaHVuay5wcmV2aW91cykpO1xuXHRcdGlmICh0aGlzLmludHJvLmxlbmd0aCkgcmV0dXJuIHRoaXMuaW50cm9bdGhpcy5pbnRyby5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRsYXN0TGluZSgpIHtcblx0XHRsZXQgbGluZUluZGV4ID0gdGhpcy5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0XHRpZiAobGluZUluZGV4ICE9PSAtMSkgcmV0dXJuIHRoaXMub3V0cm8uc3Vic3RyKGxpbmVJbmRleCArIDEpO1xuXHRcdGxldCBsaW5lU3RyID0gdGhpcy5vdXRybztcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmxhc3RDaHVuaztcblx0XHRkbyB7XG5cdFx0XHRpZiAoY2h1bmsub3V0cm8ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRsaW5lSW5kZXggPSBjaHVuay5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0XHRcdFx0aWYgKGxpbmVJbmRleCAhPT0gLTEpIHJldHVybiBjaHVuay5vdXRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdFx0XHRsaW5lU3RyID0gY2h1bmsub3V0cm8gKyBsaW5lU3RyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmNvbnRlbnQubGFzdEluZGV4T2Yobik7XG5cdFx0XHRcdGlmIChsaW5lSW5kZXggIT09IC0xKSByZXR1cm4gY2h1bmsuY29udGVudC5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdFx0XHRsaW5lU3RyID0gY2h1bmsuY29udGVudCArIGxpbmVTdHI7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmludHJvLmxhc3RJbmRleE9mKG4pO1xuXHRcdFx0XHRpZiAobGluZUluZGV4ICE9PSAtMSkgcmV0dXJuIGNodW5rLmludHJvLnN1YnN0cihsaW5lSW5kZXggKyAxKSArIGxpbmVTdHI7XG5cdFx0XHRcdGxpbmVTdHIgPSBjaHVuay5pbnRybyArIGxpbmVTdHI7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoKGNodW5rID0gY2h1bmsucHJldmlvdXMpKTtcblx0XHRsaW5lSW5kZXggPSB0aGlzLmludHJvLmxhc3RJbmRleE9mKG4pO1xuXHRcdGlmIChsaW5lSW5kZXggIT09IC0xKSByZXR1cm4gdGhpcy5pbnRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdHJldHVybiB0aGlzLmludHJvICsgbGluZVN0cjtcblx0fVxuXG5cdHNsaWNlKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHtcblx0XHR3aGlsZSAoc3RhcnQgPCAwKSBzdGFydCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHR3aGlsZSAoZW5kIDwgMCkgZW5kICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXG5cdFx0bGV0IHJlc3VsdCA9ICcnO1xuXG5cdFx0Ly8gZmluZCBzdGFydCBjaHVua1xuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHR3aGlsZSAoY2h1bmsgJiYgKGNodW5rLnN0YXJ0ID4gc3RhcnQgfHwgY2h1bmsuZW5kIDw9IHN0YXJ0KSkge1xuXHRcdFx0Ly8gZm91bmQgZW5kIGNodW5rIGJlZm9yZSBzdGFydFxuXHRcdFx0aWYgKGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdGlmIChjaHVuayAmJiBjaHVuay5lZGl0ZWQgJiYgY2h1bmsuc3RhcnQgIT09IHN0YXJ0KVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlIHJlcGxhY2VkIGNoYXJhY3RlciAke3N0YXJ0fSBhcyBzbGljZSBzdGFydCBhbmNob3IuYCk7XG5cblx0XHRjb25zdCBzdGFydENodW5rID0gY2h1bms7XG5cdFx0d2hpbGUgKGNodW5rKSB7XG5cdFx0XHRpZiAoY2h1bmsuaW50cm8gJiYgKHN0YXJ0Q2h1bmsgIT09IGNodW5rIHx8IGNodW5rLnN0YXJ0ID09PSBzdGFydCkpIHtcblx0XHRcdFx0cmVzdWx0ICs9IGNodW5rLmludHJvO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjb250YWluc0VuZCA9IGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQ7XG5cdFx0XHRpZiAoY29udGFpbnNFbmQgJiYgY2h1bmsuZWRpdGVkICYmIGNodW5rLmVuZCAhPT0gZW5kKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1c2UgcmVwbGFjZWQgY2hhcmFjdGVyICR7ZW5kfSBhcyBzbGljZSBlbmQgYW5jaG9yLmApO1xuXG5cdFx0XHRjb25zdCBzbGljZVN0YXJ0ID0gc3RhcnRDaHVuayA9PT0gY2h1bmsgPyBzdGFydCAtIGNodW5rLnN0YXJ0IDogMDtcblx0XHRcdGNvbnN0IHNsaWNlRW5kID0gY29udGFpbnNFbmQgPyBjaHVuay5jb250ZW50Lmxlbmd0aCArIGVuZCAtIGNodW5rLmVuZCA6IGNodW5rLmNvbnRlbnQubGVuZ3RoO1xuXG5cdFx0XHRyZXN1bHQgKz0gY2h1bmsuY29udGVudC5zbGljZShzbGljZVN0YXJ0LCBzbGljZUVuZCk7XG5cblx0XHRcdGlmIChjaHVuay5vdXRybyAmJiAoIWNvbnRhaW5zRW5kIHx8IGNodW5rLmVuZCA9PT0gZW5kKSkge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2h1bmsub3V0cm87XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb250YWluc0VuZCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvLyBUT0RPIGRlcHJlY2F0ZSB0aGlzPyBub3QgcmVhbGx5IHZlcnkgdXNlZnVsXG5cdHNuaXAoc3RhcnQsIGVuZCkge1xuXHRcdGNvbnN0IGNsb25lID0gdGhpcy5jbG9uZSgpO1xuXHRcdGNsb25lLnJlbW92ZSgwLCBzdGFydCk7XG5cdFx0Y2xvbmUucmVtb3ZlKGVuZCwgY2xvbmUub3JpZ2luYWwubGVuZ3RoKTtcblxuXHRcdHJldHVybiBjbG9uZTtcblx0fVxuXG5cdF9zcGxpdChpbmRleCkge1xuXHRcdGlmICh0aGlzLmJ5U3RhcnRbaW5kZXhdIHx8IHRoaXMuYnlFbmRbaW5kZXhdKSByZXR1cm47XG5cblx0XHRsZXQgY2h1bmsgPSB0aGlzLmxhc3RTZWFyY2hlZENodW5rO1xuXHRcdGNvbnN0IHNlYXJjaEZvcndhcmQgPSBpbmRleCA+IGNodW5rLmVuZDtcblxuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0aWYgKGNodW5rLmNvbnRhaW5zKGluZGV4KSkgcmV0dXJuIHRoaXMuX3NwbGl0Q2h1bmsoY2h1bmssIGluZGV4KTtcblxuXHRcdFx0Y2h1bmsgPSBzZWFyY2hGb3J3YXJkID8gdGhpcy5ieVN0YXJ0W2NodW5rLmVuZF0gOiB0aGlzLmJ5RW5kW2NodW5rLnN0YXJ0XTtcblx0XHR9XG5cdH1cblxuXHRfc3BsaXRDaHVuayhjaHVuaywgaW5kZXgpIHtcblx0XHRpZiAoY2h1bmsuZWRpdGVkICYmIGNodW5rLmNvbnRlbnQubGVuZ3RoKSB7XG5cdFx0XHQvLyB6ZXJvLWxlbmd0aCBlZGl0ZWQgY2h1bmtzIGFyZSBhIHNwZWNpYWwgY2FzZSAob3ZlcmxhcHBpbmcgcmVwbGFjZW1lbnRzKVxuXHRcdFx0Y29uc3QgbG9jID0gZ2V0TG9jYXRvcih0aGlzLm9yaWdpbmFsKShpbmRleCk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBDYW5ub3Qgc3BsaXQgYSBjaHVuayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZWRpdGVkICgke2xvYy5saW5lfToke2xvYy5jb2x1bW59IOKAkyBcIiR7Y2h1bmsub3JpZ2luYWx9XCIpYCxcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbmV3Q2h1bmsgPSBjaHVuay5zcGxpdChpbmRleCk7XG5cblx0XHR0aGlzLmJ5RW5kW2luZGV4XSA9IGNodW5rO1xuXHRcdHRoaXMuYnlTdGFydFtpbmRleF0gPSBuZXdDaHVuaztcblx0XHR0aGlzLmJ5RW5kW25ld0NodW5rLmVuZF0gPSBuZXdDaHVuaztcblxuXHRcdGlmIChjaHVuayA9PT0gdGhpcy5sYXN0Q2h1bmspIHRoaXMubGFzdENodW5rID0gbmV3Q2h1bms7XG5cblx0XHR0aGlzLmxhc3RTZWFyY2hlZENodW5rID0gY2h1bms7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRsZXQgc3RyID0gdGhpcy5pbnRybztcblxuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHR3aGlsZSAoY2h1bmspIHtcblx0XHRcdHN0ciArPSBjaHVuay50b1N0cmluZygpO1xuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHIgKyB0aGlzLm91dHJvO1xuXHR9XG5cblx0aXNFbXB0eSgpIHtcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQoY2h1bmsuaW50cm8ubGVuZ3RoICYmIGNodW5rLmludHJvLnRyaW0oKSkgfHxcblx0XHRcdFx0KGNodW5rLmNvbnRlbnQubGVuZ3RoICYmIGNodW5rLmNvbnRlbnQudHJpbSgpKSB8fFxuXHRcdFx0XHQoY2h1bmsub3V0cm8ubGVuZ3RoICYmIGNodW5rLm91dHJvLnRyaW0oKSlcblx0XHRcdClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gd2hpbGUgKChjaHVuayA9IGNodW5rLm5leHQpKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGxlbmd0aCgpIHtcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cdFx0bGV0IGxlbmd0aCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0bGVuZ3RoICs9IGNodW5rLmludHJvLmxlbmd0aCArIGNodW5rLmNvbnRlbnQubGVuZ3RoICsgY2h1bmsub3V0cm8ubGVuZ3RoO1xuXHRcdH0gd2hpbGUgKChjaHVuayA9IGNodW5rLm5leHQpKTtcblx0XHRyZXR1cm4gbGVuZ3RoO1xuXHR9XG5cblx0dHJpbUxpbmVzKCkge1xuXHRcdHJldHVybiB0aGlzLnRyaW0oJ1tcXFxcclxcXFxuXScpO1xuXHR9XG5cblx0dHJpbShjaGFyVHlwZSkge1xuXHRcdHJldHVybiB0aGlzLnRyaW1TdGFydChjaGFyVHlwZSkudHJpbUVuZChjaGFyVHlwZSk7XG5cdH1cblxuXHR0cmltRW5kQWJvcnRlZChjaGFyVHlwZSkge1xuXHRcdGNvbnN0IHJ4ID0gbmV3IFJlZ0V4cCgoY2hhclR5cGUgfHwgJ1xcXFxzJykgKyAnKyQnKTtcblxuXHRcdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRpZiAodGhpcy5vdXRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG5cdFx0bGV0IGNodW5rID0gdGhpcy5sYXN0Q2h1bms7XG5cblx0XHRkbyB7XG5cdFx0XHRjb25zdCBlbmQgPSBjaHVuay5lbmQ7XG5cdFx0XHRjb25zdCBhYm9ydGVkID0gY2h1bmsudHJpbUVuZChyeCk7XG5cblx0XHRcdC8vIGlmIGNodW5rIHdhcyB0cmltbWVkLCB3ZSBoYXZlIGEgbmV3IGxhc3RDaHVua1xuXHRcdFx0aWYgKGNodW5rLmVuZCAhPT0gZW5kKSB7XG5cdFx0XHRcdGlmICh0aGlzLmxhc3RDaHVuayA9PT0gY2h1bmspIHtcblx0XHRcdFx0XHR0aGlzLmxhc3RDaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmJ5RW5kW2NodW5rLmVuZF0gPSBjaHVuaztcblx0XHRcdFx0dGhpcy5ieVN0YXJ0W2NodW5rLm5leHQuc3RhcnRdID0gY2h1bmsubmV4dDtcblx0XHRcdFx0dGhpcy5ieUVuZFtjaHVuay5uZXh0LmVuZF0gPSBjaHVuay5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWJvcnRlZCkgcmV0dXJuIHRydWU7XG5cdFx0XHRjaHVuayA9IGNodW5rLnByZXZpb3VzO1xuXHRcdH0gd2hpbGUgKGNodW5rKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHRyaW1FbmQoY2hhclR5cGUpIHtcblx0XHR0aGlzLnRyaW1FbmRBYm9ydGVkKGNoYXJUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0cmltU3RhcnRBYm9ydGVkKGNoYXJUeXBlKSB7XG5cdFx0Y29uc3QgcnggPSBuZXcgUmVnRXhwKCdeJyArIChjaGFyVHlwZSB8fCAnXFxcXHMnKSArICcrJyk7XG5cblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cdFx0aWYgKHRoaXMuaW50cm8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblxuXHRcdGRvIHtcblx0XHRcdGNvbnN0IGVuZCA9IGNodW5rLmVuZDtcblx0XHRcdGNvbnN0IGFib3J0ZWQgPSBjaHVuay50cmltU3RhcnQocngpO1xuXG5cdFx0XHRpZiAoY2h1bmsuZW5kICE9PSBlbmQpIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlLi4uXG5cdFx0XHRcdGlmIChjaHVuayA9PT0gdGhpcy5sYXN0Q2h1bmspIHRoaXMubGFzdENodW5rID0gY2h1bmsubmV4dDtcblxuXHRcdFx0XHR0aGlzLmJ5RW5kW2NodW5rLmVuZF0gPSBjaHVuaztcblx0XHRcdFx0dGhpcy5ieVN0YXJ0W2NodW5rLm5leHQuc3RhcnRdID0gY2h1bmsubmV4dDtcblx0XHRcdFx0dGhpcy5ieUVuZFtjaHVuay5uZXh0LmVuZF0gPSBjaHVuay5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWJvcnRlZCkgcmV0dXJuIHRydWU7XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fSB3aGlsZSAoY2h1bmspO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dHJpbVN0YXJ0KGNoYXJUeXBlKSB7XG5cdFx0dGhpcy50cmltU3RhcnRBYm9ydGVkKGNoYXJUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGhhc0NoYW5nZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3JpZ2luYWwgIT09IHRoaXMudG9TdHJpbmcoKTtcblx0fVxuXG5cdF9yZXBsYWNlUmVnZXhwKHNlYXJjaFZhbHVlLCByZXBsYWNlbWVudCkge1xuXHRcdGZ1bmN0aW9uIGdldFJlcGxhY2VtZW50KG1hdGNoLCBzdHIpIHtcblx0XHRcdGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiByZXBsYWNlbWVudC5yZXBsYWNlKC9cXCQoXFwkfCZ8XFxkKykvZywgKF8sIGkpID0+IHtcblx0XHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwbGFjZSNzcGVjaWZ5aW5nX2Ffc3RyaW5nX2FzX2FfcGFyYW1ldGVyXG5cdFx0XHRcdFx0aWYgKGkgPT09ICckJykgcmV0dXJuICckJztcblx0XHRcdFx0XHRpZiAoaSA9PT0gJyYnKSByZXR1cm4gbWF0Y2hbMF07XG5cdFx0XHRcdFx0Y29uc3QgbnVtID0gK2k7XG5cdFx0XHRcdFx0aWYgKG51bSA8IG1hdGNoLmxlbmd0aCkgcmV0dXJuIG1hdGNoWytpXTtcblx0XHRcdFx0XHRyZXR1cm4gYCQke2l9YDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVwbGFjZW1lbnQoLi4ubWF0Y2gsIG1hdGNoLmluZGV4LCBzdHIsIG1hdGNoLmdyb3Vwcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG1hdGNoQWxsKHJlLCBzdHIpIHtcblx0XHRcdGxldCBtYXRjaDtcblx0XHRcdGNvbnN0IG1hdGNoZXMgPSBbXTtcblx0XHRcdHdoaWxlICgobWF0Y2ggPSByZS5leGVjKHN0cikpKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaChtYXRjaCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHR9XG5cdFx0aWYgKHNlYXJjaFZhbHVlLmdsb2JhbCkge1xuXHRcdFx0Y29uc3QgbWF0Y2hlcyA9IG1hdGNoQWxsKHNlYXJjaFZhbHVlLCB0aGlzLm9yaWdpbmFsKTtcblx0XHRcdG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcblx0XHRcdFx0aWYgKG1hdGNoLmluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlbWVudCA9IGdldFJlcGxhY2VtZW50KG1hdGNoLCB0aGlzLm9yaWdpbmFsKTtcblx0XHRcdFx0XHRpZiAocmVwbGFjZW1lbnQgIT09IG1hdGNoWzBdKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm92ZXJ3cml0ZShcblx0XHRcdFx0XHRcdFx0bWF0Y2guaW5kZXgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRyZXBsYWNlbWVudFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBtYXRjaCA9IHRoaXMub3JpZ2luYWwubWF0Y2goc2VhcmNoVmFsdWUpO1xuXHRcdFx0aWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBnZXRSZXBsYWNlbWVudChtYXRjaCwgdGhpcy5vcmlnaW5hbCk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCAhPT0gbWF0Y2hbMF0pIHtcblx0XHRcdFx0XHR0aGlzLm92ZXJ3cml0ZShcblx0XHRcdFx0XHRcdG1hdGNoLmluZGV4LFxuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsXG5cdFx0XHRcdFx0XHRyZXBsYWNlbWVudFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfcmVwbGFjZVN0cmluZyhzdHJpbmcsIHJlcGxhY2VtZW50KSB7XG5cdFx0Y29uc3QgeyBvcmlnaW5hbCB9ID0gdGhpcztcblx0XHRjb25zdCBpbmRleCA9IG9yaWdpbmFsLmluZGV4T2Yoc3RyaW5nKTtcblxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHRoaXMub3ZlcndyaXRlKGluZGV4LCBpbmRleCArIHN0cmluZy5sZW5ndGgsIHJlcGxhY2VtZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VtZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBzZWFyY2hWYWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXBsYWNlU3RyaW5nKHNlYXJjaFZhbHVlLCByZXBsYWNlbWVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3JlcGxhY2VSZWdleHAoc2VhcmNoVmFsdWUsIHJlcGxhY2VtZW50KTtcblx0fVxuXG5cdF9yZXBsYWNlQWxsU3RyaW5nKHN0cmluZywgcmVwbGFjZW1lbnQpIHtcblx0XHRjb25zdCB7IG9yaWdpbmFsIH0gPSB0aGlzO1xuXHRcdGNvbnN0IHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0Zm9yIChcblx0XHRcdGxldCBpbmRleCA9IG9yaWdpbmFsLmluZGV4T2Yoc3RyaW5nKTtcblx0XHRcdGluZGV4ICE9PSAtMTtcblx0XHRcdGluZGV4ID0gb3JpZ2luYWwuaW5kZXhPZihzdHJpbmcsIGluZGV4ICsgc3RyaW5nTGVuZ3RoKVxuXHRcdCkge1xuXHRcdFx0Y29uc3QgcHJldmlvdXMgPSBvcmlnaW5hbC5zbGljZShpbmRleCwgaW5kZXggKyBzdHJpbmdMZW5ndGgpO1xuXHRcdFx0aWYgKHByZXZpb3VzICE9PSByZXBsYWNlbWVudClcblx0XHRcdFx0dGhpcy5vdmVyd3JpdGUoaW5kZXgsIGluZGV4ICsgc3RyaW5nTGVuZ3RoLCByZXBsYWNlbWVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyZXBsYWNlQWxsKHNlYXJjaFZhbHVlLCByZXBsYWNlbWVudCkge1xuXHRcdGlmICh0eXBlb2Ygc2VhcmNoVmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVwbGFjZUFsbFN0cmluZyhzZWFyY2hWYWx1ZSwgcmVwbGFjZW1lbnQpO1xuXHRcdH1cblxuXHRcdGlmICghc2VhcmNoVmFsdWUuZ2xvYmFsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0XHQnTWFnaWNTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgY2FsbGVkIHdpdGggYSBub24tZ2xvYmFsIFJlZ0V4cCBhcmd1bWVudCcsXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9yZXBsYWNlUmVnZXhwKHNlYXJjaFZhbHVlLCByZXBsYWNlbWVudCk7XG5cdH1cbn1cblxuY29uc3QgaGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmNsYXNzIEJ1bmRsZSB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuaW50cm8gPSBvcHRpb25zLmludHJvIHx8ICcnO1xuXHRcdHRoaXMuc2VwYXJhdG9yID0gb3B0aW9ucy5zZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2VwYXJhdG9yIDogJ1xcbic7XG5cdFx0dGhpcy5zb3VyY2VzID0gW107XG5cdFx0dGhpcy51bmlxdWVTb3VyY2VzID0gW107XG5cdFx0dGhpcy51bmlxdWVTb3VyY2VJbmRleEJ5RmlsZW5hbWUgPSB7fTtcblx0fVxuXG5cdGFkZFNvdXJjZShzb3VyY2UpIHtcblx0XHRpZiAoc291cmNlIGluc3RhbmNlb2YgTWFnaWNTdHJpbmcpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZFNvdXJjZSh7XG5cdFx0XHRcdGNvbnRlbnQ6IHNvdXJjZSxcblx0XHRcdFx0ZmlsZW5hbWU6IHNvdXJjZS5maWxlbmFtZSxcblx0XHRcdFx0c2VwYXJhdG9yOiB0aGlzLnNlcGFyYXRvcixcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhc291cmNlLmNvbnRlbnQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J2J1bmRsZS5hZGRTb3VyY2UoKSB0YWtlcyBhbiBvYmplY3Qgd2l0aCBhIGBjb250ZW50YCBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIE1hZ2ljU3RyaW5nLCBhbmQgYW4gb3B0aW9uYWwgYGZpbGVuYW1lYCcsXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdFsnZmlsZW5hbWUnLCAnaWdub3JlTGlzdCcsICdpbmRlbnRFeGNsdXNpb25SYW5nZXMnLCAnc2VwYXJhdG9yJ10uZm9yRWFjaCgob3B0aW9uKSA9PiB7XG5cdFx0XHRpZiAoIWhhc093blByb3AuY2FsbChzb3VyY2UsIG9wdGlvbikpIHNvdXJjZVtvcHRpb25dID0gc291cmNlLmNvbnRlbnRbb3B0aW9uXTtcblx0XHR9KTtcblxuXHRcdGlmIChzb3VyY2Uuc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIFRPRE8gdGhlcmUncyBhIGJ1bmNoIG9mIHRoaXMgc29ydCBvZiB0aGluZywgbmVlZHMgY2xlYW5pbmcgdXBcblx0XHRcdHNvdXJjZS5zZXBhcmF0b3IgPSB0aGlzLnNlcGFyYXRvcjtcblx0XHR9XG5cblx0XHRpZiAoc291cmNlLmZpbGVuYW1lKSB7XG5cdFx0XHRpZiAoIWhhc093blByb3AuY2FsbCh0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZSwgc291cmNlLmZpbGVuYW1lKSkge1xuXHRcdFx0XHR0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZVtzb3VyY2UuZmlsZW5hbWVdID0gdGhpcy51bmlxdWVTb3VyY2VzLmxlbmd0aDtcblx0XHRcdFx0dGhpcy51bmlxdWVTb3VyY2VzLnB1c2goeyBmaWxlbmFtZTogc291cmNlLmZpbGVuYW1lLCBjb250ZW50OiBzb3VyY2UuY29udGVudC5vcmlnaW5hbCB9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHVuaXF1ZVNvdXJjZSA9IHRoaXMudW5pcXVlU291cmNlc1t0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZVtzb3VyY2UuZmlsZW5hbWVdXTtcblx0XHRcdFx0aWYgKHNvdXJjZS5jb250ZW50Lm9yaWdpbmFsICE9PSB1bmlxdWVTb3VyY2UuY29udGVudCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBzb3VyY2U6IHNhbWUgZmlsZW5hbWUgKCR7c291cmNlLmZpbGVuYW1lfSksIGRpZmZlcmVudCBjb250ZW50c2ApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGFwcGVuZChzdHIsIG9wdGlvbnMpIHtcblx0XHR0aGlzLmFkZFNvdXJjZSh7XG5cdFx0XHRjb250ZW50OiBuZXcgTWFnaWNTdHJpbmcoc3RyKSxcblx0XHRcdHNlcGFyYXRvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXBhcmF0b3IpIHx8ICcnLFxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRjbG9uZSgpIHtcblx0XHRjb25zdCBidW5kbGUgPSBuZXcgQnVuZGxlKHtcblx0XHRcdGludHJvOiB0aGlzLmludHJvLFxuXHRcdFx0c2VwYXJhdG9yOiB0aGlzLnNlcGFyYXRvcixcblx0XHR9KTtcblxuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcblx0XHRcdGJ1bmRsZS5hZGRTb3VyY2Uoe1xuXHRcdFx0XHRmaWxlbmFtZTogc291cmNlLmZpbGVuYW1lLFxuXHRcdFx0XHRjb250ZW50OiBzb3VyY2UuY29udGVudC5jbG9uZSgpLFxuXHRcdFx0XHRzZXBhcmF0b3I6IHNvdXJjZS5zZXBhcmF0b3IsXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBidW5kbGU7XG5cdH1cblxuXHRnZW5lcmF0ZURlY29kZWRNYXAob3B0aW9ucyA9IHt9KSB7XG5cdFx0Y29uc3QgbmFtZXMgPSBbXTtcblx0XHRsZXQgeF9nb29nbGVfaWdub3JlTGlzdCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG5cdFx0XHRPYmplY3Qua2V5cyhzb3VyY2UuY29udGVudC5zdG9yZWROYW1lcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuXHRcdFx0XHRpZiAoIX5uYW1lcy5pbmRleE9mKG5hbWUpKSBuYW1lcy5wdXNoKG5hbWUpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRjb25zdCBtYXBwaW5ncyA9IG5ldyBNYXBwaW5ncyhvcHRpb25zLmhpcmVzKTtcblxuXHRcdGlmICh0aGlzLmludHJvKSB7XG5cdFx0XHRtYXBwaW5ncy5hZHZhbmNlKHRoaXMuaW50cm8pO1xuXHRcdH1cblxuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKChzb3VyY2UsIGkpID0+IHtcblx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRtYXBwaW5ncy5hZHZhbmNlKHRoaXMuc2VwYXJhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc291cmNlSW5kZXggPSBzb3VyY2UuZmlsZW5hbWUgPyB0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZVtzb3VyY2UuZmlsZW5hbWVdIDogLTE7XG5cdFx0XHRjb25zdCBtYWdpY1N0cmluZyA9IHNvdXJjZS5jb250ZW50O1xuXHRcdFx0Y29uc3QgbG9jYXRlID0gZ2V0TG9jYXRvcihtYWdpY1N0cmluZy5vcmlnaW5hbCk7XG5cblx0XHRcdGlmIChtYWdpY1N0cmluZy5pbnRybykge1xuXHRcdFx0XHRtYXBwaW5ncy5hZHZhbmNlKG1hZ2ljU3RyaW5nLmludHJvKTtcblx0XHRcdH1cblxuXHRcdFx0bWFnaWNTdHJpbmcuZmlyc3RDaHVuay5lYWNoTmV4dCgoY2h1bmspID0+IHtcblx0XHRcdFx0Y29uc3QgbG9jID0gbG9jYXRlKGNodW5rLnN0YXJ0KTtcblxuXHRcdFx0XHRpZiAoY2h1bmsuaW50cm8ubGVuZ3RoKSBtYXBwaW5ncy5hZHZhbmNlKGNodW5rLmludHJvKTtcblxuXHRcdFx0XHRpZiAoc291cmNlLmZpbGVuYW1lKSB7XG5cdFx0XHRcdFx0aWYgKGNodW5rLmVkaXRlZCkge1xuXHRcdFx0XHRcdFx0bWFwcGluZ3MuYWRkRWRpdChcblx0XHRcdFx0XHRcdFx0c291cmNlSW5kZXgsXG5cdFx0XHRcdFx0XHRcdGNodW5rLmNvbnRlbnQsXG5cdFx0XHRcdFx0XHRcdGxvYyxcblx0XHRcdFx0XHRcdFx0Y2h1bmsuc3RvcmVOYW1lID8gbmFtZXMuaW5kZXhPZihjaHVuay5vcmlnaW5hbCkgOiAtMSxcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hcHBpbmdzLmFkZFVuZWRpdGVkQ2h1bmsoXG5cdFx0XHRcdFx0XHRcdHNvdXJjZUluZGV4LFxuXHRcdFx0XHRcdFx0XHRjaHVuayxcblx0XHRcdFx0XHRcdFx0bWFnaWNTdHJpbmcub3JpZ2luYWwsXG5cdFx0XHRcdFx0XHRcdGxvYyxcblx0XHRcdFx0XHRcdFx0bWFnaWNTdHJpbmcuc291cmNlbWFwTG9jYXRpb25zLFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWFwcGluZ3MuYWR2YW5jZShjaHVuay5jb250ZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGgpIG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsub3V0cm8pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChtYWdpY1N0cmluZy5vdXRybykge1xuXHRcdFx0XHRtYXBwaW5ncy5hZHZhbmNlKG1hZ2ljU3RyaW5nLm91dHJvKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNvdXJjZS5pZ25vcmVMaXN0ICYmIHNvdXJjZUluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRpZiAoeF9nb29nbGVfaWdub3JlTGlzdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0eF9nb29nbGVfaWdub3JlTGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHhfZ29vZ2xlX2lnbm9yZUxpc3QucHVzaChzb3VyY2VJbmRleCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZmlsZTogb3B0aW9ucy5maWxlID8gb3B0aW9ucy5maWxlLnNwbGl0KC9bL1xcXFxdLykucG9wKCkgOiB1bmRlZmluZWQsXG5cdFx0XHRzb3VyY2VzOiB0aGlzLnVuaXF1ZVNvdXJjZXMubWFwKChzb3VyY2UpID0+IHtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMuZmlsZSA/IGdldFJlbGF0aXZlUGF0aChvcHRpb25zLmZpbGUsIHNvdXJjZS5maWxlbmFtZSkgOiBzb3VyY2UuZmlsZW5hbWU7XG5cdFx0XHR9KSxcblx0XHRcdHNvdXJjZXNDb250ZW50OiB0aGlzLnVuaXF1ZVNvdXJjZXMubWFwKChzb3VyY2UpID0+IHtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMuaW5jbHVkZUNvbnRlbnQgPyBzb3VyY2UuY29udGVudCA6IG51bGw7XG5cdFx0XHR9KSxcblx0XHRcdG5hbWVzLFxuXHRcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLnJhdyxcblx0XHRcdHhfZ29vZ2xlX2lnbm9yZUxpc3QsXG5cdFx0fTtcblx0fVxuXG5cdGdlbmVyYXRlTWFwKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IFNvdXJjZU1hcCh0aGlzLmdlbmVyYXRlRGVjb2RlZE1hcChvcHRpb25zKSk7XG5cdH1cblxuXHRnZXRJbmRlbnRTdHJpbmcoKSB7XG5cdFx0Y29uc3QgaW5kZW50U3RyaW5nQ291bnRzID0ge307XG5cblx0XHR0aGlzLnNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG5cdFx0XHRjb25zdCBpbmRlbnRTdHIgPSBzb3VyY2UuY29udGVudC5fZ2V0UmF3SW5kZW50U3RyaW5nKCk7XG5cblx0XHRcdGlmIChpbmRlbnRTdHIgPT09IG51bGwpIHJldHVybjtcblxuXHRcdFx0aWYgKCFpbmRlbnRTdHJpbmdDb3VudHNbaW5kZW50U3RyXSkgaW5kZW50U3RyaW5nQ291bnRzW2luZGVudFN0cl0gPSAwO1xuXHRcdFx0aW5kZW50U3RyaW5nQ291bnRzW2luZGVudFN0cl0gKz0gMTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHRPYmplY3Qua2V5cyhpbmRlbnRTdHJpbmdDb3VudHMpLnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0cmV0dXJuIGluZGVudFN0cmluZ0NvdW50c1thXSAtIGluZGVudFN0cmluZ0NvdW50c1tiXTtcblx0XHRcdH0pWzBdIHx8ICdcXHQnXG5cdFx0KTtcblx0fVxuXG5cdGluZGVudChpbmRlbnRTdHIpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdGluZGVudFN0ciA9IHRoaXMuZ2V0SW5kZW50U3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGluZGVudFN0ciA9PT0gJycpIHJldHVybiB0aGlzOyAvLyBub29wXG5cblx0XHRsZXQgdHJhaWxpbmdOZXdsaW5lID0gIXRoaXMuaW50cm8gfHwgdGhpcy5pbnRyby5zbGljZSgtMSkgPT09ICdcXG4nO1xuXG5cdFx0dGhpcy5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSwgaSkgPT4ge1xuXHRcdFx0Y29uc3Qgc2VwYXJhdG9yID0gc291cmNlLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gc291cmNlLnNlcGFyYXRvciA6IHRoaXMuc2VwYXJhdG9yO1xuXHRcdFx0Y29uc3QgaW5kZW50U3RhcnQgPSB0cmFpbGluZ05ld2xpbmUgfHwgKGkgPiAwICYmIC9cXHI/XFxuJC8udGVzdChzZXBhcmF0b3IpKTtcblxuXHRcdFx0c291cmNlLmNvbnRlbnQuaW5kZW50KGluZGVudFN0ciwge1xuXHRcdFx0XHRleGNsdWRlOiBzb3VyY2UuaW5kZW50RXhjbHVzaW9uUmFuZ2VzLFxuXHRcdFx0XHRpbmRlbnRTdGFydCwgLy86IHRyYWlsaW5nTmV3bGluZSB8fCAvXFxyP1xcbiQvLnRlc3QoIHNlcGFyYXRvciApICAvL3RydWUvLy9cXHI/XFxuLy50ZXN0KCBzZXBhcmF0b3IgKVxuXHRcdFx0fSk7XG5cblx0XHRcdHRyYWlsaW5nTmV3bGluZSA9IHNvdXJjZS5jb250ZW50Lmxhc3RDaGFyKCkgPT09ICdcXG4nO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMuaW50cm8pIHtcblx0XHRcdHRoaXMuaW50cm8gPVxuXHRcdFx0XHRpbmRlbnRTdHIgK1xuXHRcdFx0XHR0aGlzLmludHJvLnJlcGxhY2UoL15bXlxcbl0vZ20sIChtYXRjaCwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gaW5kZXggPiAwID8gaW5kZW50U3RyICsgbWF0Y2ggOiBtYXRjaDtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRwcmVwZW5kKHN0cikge1xuXHRcdHRoaXMuaW50cm8gPSBzdHIgKyB0aGlzLmludHJvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0Y29uc3QgYm9keSA9IHRoaXMuc291cmNlc1xuXHRcdFx0Lm1hcCgoc291cmNlLCBpKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlcGFyYXRvciA9IHNvdXJjZS5zZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IHNvdXJjZS5zZXBhcmF0b3IgOiB0aGlzLnNlcGFyYXRvcjtcblx0XHRcdFx0Y29uc3Qgc3RyID0gKGkgPiAwID8gc2VwYXJhdG9yIDogJycpICsgc291cmNlLmNvbnRlbnQudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fSlcblx0XHRcdC5qb2luKCcnKTtcblxuXHRcdHJldHVybiB0aGlzLmludHJvICsgYm9keTtcblx0fVxuXG5cdGlzRW1wdHkoKSB7XG5cdFx0aWYgKHRoaXMuaW50cm8ubGVuZ3RoICYmIHRoaXMuaW50cm8udHJpbSgpKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHRoaXMuc291cmNlcy5zb21lKChzb3VyY2UpID0+ICFzb3VyY2UuY29udGVudC5pc0VtcHR5KCkpKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc291cmNlcy5yZWR1Y2UoXG5cdFx0XHQobGVuZ3RoLCBzb3VyY2UpID0+IGxlbmd0aCArIHNvdXJjZS5jb250ZW50Lmxlbmd0aCgpLFxuXHRcdFx0dGhpcy5pbnRyby5sZW5ndGgsXG5cdFx0KTtcblx0fVxuXG5cdHRyaW1MaW5lcygpIHtcblx0XHRyZXR1cm4gdGhpcy50cmltKCdbXFxcXHJcXFxcbl0nKTtcblx0fVxuXG5cdHRyaW0oY2hhclR5cGUpIHtcblx0XHRyZXR1cm4gdGhpcy50cmltU3RhcnQoY2hhclR5cGUpLnRyaW1FbmQoY2hhclR5cGUpO1xuXHR9XG5cblx0dHJpbVN0YXJ0KGNoYXJUeXBlKSB7XG5cdFx0Y29uc3QgcnggPSBuZXcgUmVnRXhwKCdeJyArIChjaGFyVHlwZSB8fCAnXFxcXHMnKSArICcrJyk7XG5cdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZShyeCwgJycpO1xuXG5cdFx0aWYgKCF0aGlzLmludHJvKSB7XG5cdFx0XHRsZXQgc291cmNlO1xuXHRcdFx0bGV0IGkgPSAwO1xuXG5cdFx0XHRkbyB7XG5cdFx0XHRcdHNvdXJjZSA9IHRoaXMuc291cmNlc1tpKytdO1xuXHRcdFx0XHRpZiAoIXNvdXJjZSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICghc291cmNlLmNvbnRlbnQudHJpbVN0YXJ0QWJvcnRlZChjaGFyVHlwZSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dHJpbUVuZChjaGFyVHlwZSkge1xuXHRcdGNvbnN0IHJ4ID0gbmV3IFJlZ0V4cCgoY2hhclR5cGUgfHwgJ1xcXFxzJykgKyAnKyQnKTtcblxuXHRcdGxldCBzb3VyY2U7XG5cdFx0bGV0IGkgPSB0aGlzLnNvdXJjZXMubGVuZ3RoIC0gMTtcblxuXHRcdGRvIHtcblx0XHRcdHNvdXJjZSA9IHRoaXMuc291cmNlc1tpLS1dO1xuXHRcdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9IHdoaWxlICghc291cmNlLmNvbnRlbnQudHJpbUVuZEFib3J0ZWQoY2hhclR5cGUpKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbmV4cG9ydCB7IEJ1bmRsZSwgU291cmNlTWFwLCBNYWdpY1N0cmluZyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWdpYy1zdHJpbmcuZXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/magic-string/dist/magic-string.es.mjs\n"));

/***/ })

}]);